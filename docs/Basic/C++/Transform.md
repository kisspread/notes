![alt text](../../assets/images/Transform_image.webp)

在 3D 计算中，**Transform 乘法（TTransform 相乘）**和**矩阵乘法**都是用来**合并多个变换（旋转、缩放、平移）**的，但它们的**数据结构和计算方式不同**。  

---

## **1. Transform（TTransform）相乘**
### **核心思想**
TTransform 主要基于 **四元数（Quaternion）+ 缩放（Scale）+ 平移（Translation）** 来存储变换，而不是直接使用 4×4 矩阵。

#### **计算方式**
$$
Q(AxB) = Q(B) * Q(A)
$$
$$
S(AxB) = S(A) * S(B)
$$
$$
T(AxB) = Q(B) * S(B) * T(A) * Q(B)^{-1} + T(B)
$$

#### **优点**
✅ **避免了矩阵的数值误差**：  
- 旋转部分使用**四元数**，不会出现浮点数累积误差，保证**旋转稳定性**。  
- 适用于**游戏动画、骨骼系统、物体变换**等场景。  

✅ **计算更高效**：  
- **四元数乘法**比矩阵乘法更快（减少了大量冗余计算）。  
- 对于**旋转**，四元数只需要 4 个值，而 3×3 旋转矩阵需要 9 个值。

✅ **更容易进行插值**：  
- 用于**平滑过渡动画（Slerp 插值）**。

#### **缺点**
❌ **不适用于投影变换**：  
- 不能表示**透视投影、剪切（Shear）**等复杂变换。  
- 在**渲染管线**中，最终仍然需要转换为 4×4 矩阵。

---

## **2. 矩阵相乘**
### **核心思想**
矩阵变换基于 **4×4 齐次变换矩阵**，可以同时存储 **旋转、缩放、平移、投影等所有变换**。

#### **计算方式**
如果 `M_A` 和 `M_B` 是 4×4 变换矩阵：
$$
M_{AxB} = M_B \times M_A
$$
矩阵相乘可以合并多个变换，最终一个 `4×4` 矩阵可以表示完整的 3D 变换：
$$
M =
\begin{bmatrix}
R_{3×3} & T_{3×1} \\
0 & 1
\end{bmatrix}
$$
其中：
- `R3×3` 是旋转+缩放矩阵
- `T3×1` 是平移向量

#### **优点**
✅ **能表示所有线性变换**（旋转、缩放、平移、投影）  
✅ **适用于渲染管线**（GPU 计算时，所有变换都以 4×4 矩阵存储）  
✅ **能直接作用于向量计算**（点 * 矩阵 = 变换后点）

#### **缺点**
❌ **浮点误差累积，可能导致非正交旋转（失去单位长度）**  
❌ **计算复杂度高**，比四元数旋转慢  
❌ **难以进行插值计算**（不能直接用于 Slerp 插值）

---

## **3. 对比总结**
| **比较项**   | **TTransform 乘法** | **矩阵相乘（4×4）** |
|-------------|-----------------|-----------------|
| **存储方式** | 四元数 + 缩放 + 平移 | 4×4 矩阵 |
| **旋转计算** | 四元数相乘（快速） | 矩阵乘法（慢） |
| **平移计算** | 需要四元数影响 | 直接矩阵乘法 |
| **缩放计算** | 直接标量乘法 | 受矩阵影响 |
| **插值（动画）** | **Slerp 插值好** | 不能直接插值 |
| **数值稳定性** | **无漂移误差** | 可能有数值漂移 |
| **投影/透视支持** | ❌ 不支持 | ✅ 可做透视变换 |
| **适用场景** | **骨骼动画、游戏变换** | **渲染、物理计算** |

---

## **4. 什么时候用 TTransform，什么时候用矩阵？**
✅ **游戏中物体变换（骨骼、动画、物理模拟）** → **TTransform**  
✅ **渲染、相机投影、复杂变换（如 UI 变换）** → **4×4 矩阵**  

在 Unreal Engine 里，**TTransform 主要用于对象变换，最后仍然需要转换为 4×4 矩阵供 GPU 渲染使用**。